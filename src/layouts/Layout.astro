---
import "../styles/index.css";

interface Props {
	title?: string;
}

const { title = "Astro Basics" } = Astro.props;
---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width" />

		<meta name="generator" content={Astro.generator} />
		<title>{title}</title>

		<!-- Preload sprite sheet for immediate display -->
		<link
			rel="preload"
			href="/sprites/sprite_sheet.avif"
			as="image"
			fetchpriority="high"
		/>

		<!-- Inline critical loader CSS for instant visibility -->
		<style>
			.loader-wrapper {
				position: fixed;
				inset: 0;
				background: black;
				display: flex;
				align-items: center;
				justify-content: center;
				z-index: 9999;
				opacity: 1;
				transition: opacity 0.5s ease-out;
			}

			.loader-wrapper.fade-out {
				opacity: 0;
				pointer-events: none;
			}

			.loader-content {
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 2rem;
			}

			#sprite-canvas {
				image-rendering: pixelated;
				image-rendering: crisp-edges;
			}

			@keyframes spin {
				to {
					transform: rotate(360deg);
				}
			}
		</style>
	</head>
	<body>
		<!-- Inline Loader HTML - shows immediately -->
		<div id="loader-wrapper" class="loader-wrapper">
			<div class="loader-content">
				<canvas id="sprite-canvas"></canvas>
			</div>
		</div>

		<!-- Inline script - starts progress animation immediately -->
		<script is:inline>
			// Simple reliable loader
			var isHiding = false;
			var loaderWrapper = document.getElementById("loader-wrapper");

			// Listen for load complete event
			function handleLoadComplete() {
				if (isHiding) return;
				isHiding = true;

				setTimeout(function () {
					if (loaderWrapper) {
						loaderWrapper.classList.add("fade-out");
						setTimeout(function () {
							loaderWrapper.style.display = "none";
						}, 500);
					}
				}, 300);
			}

			// Track when the page started loading
			var pageStartTime = Date.now();
			var minimumLoadTime = 6000; // 5 seconds minimum

			// When page resources finish loading
			window.addEventListener("load", function () {
				var elapsedTime = Date.now() - pageStartTime;
				var remainingTime = Math.max(0, minimumLoadTime - elapsedTime);

				console.log(
					"Window loaded after " +
						elapsedTime +
						"ms, waiting " +
						remainingTime +
						"ms more...",
				);

				// Wait for remaining time to reach 5 seconds total
				setTimeout(function () {
					console.log(
						"Minimum 5 seconds elapsed, completing loader...",
					);
					handleLoadComplete();
				}, remainingTime);
			});
		</script>

		<!-- PixiJS Sprite Animation -->
		<script>
			import {
				Application,
				Assets,
				Sprite,
				Texture,
				Rectangle,
			} from "pixi.js";

			// Sprite sheet configuration - Production settings
			const SPRITE_CONFIG = {
				path: "/sprites/sprite_sheet.avif",
				width: 7500,
				height: 11000,
				columns: 15,
				rows: 22,
				frameWidth: 7500 / 15, // ~733.33px
				frameHeight: 11000 / 22, // ~340.91px
				fps: 60, // 60 FPS for smooth animation
				scale: 0.6, // Larger scale to show complete frames
			};

			async function initSpriteAnimation() {
				const canvasElement = document.getElementById("sprite-canvas");
				if (!canvasElement) return;

				// Create PixiJS application with production-level settings
				const app = new Application();
				await app.init({
					canvas: canvasElement as HTMLCanvasElement,
					width: SPRITE_CONFIG.frameWidth * SPRITE_CONFIG.scale,
					height: SPRITE_CONFIG.frameHeight * SPRITE_CONFIG.scale,
					backgroundColor: 0x000000,
					backgroundAlpha: 0,
					antialias: false, // Crisp pixel art rendering
					resolution: window.devicePixelRatio || 1,
					autoDensity: true,
					autoStart: true, // Start rendering immediately
				});

				// Lock to 60 FPS for production-level smoothness
				app.ticker.maxFPS = 60;

				try {
					// Load sprite sheet with caching
					Assets.add({
						alias: "spritesheet",
						src: SPRITE_CONFIG.path,
					});
					const texture = await Assets.load("spritesheet");

					// Create all frames (row by row)
					const frames: Texture[] = [];
					for (let row = 0; row < SPRITE_CONFIG.rows; row++) {
						for (let col = 0; col < SPRITE_CONFIG.columns; col++) {
							const frame = new Texture({
								source: texture.source,
								frame: new Rectangle(
									col * SPRITE_CONFIG.frameWidth,
									row * SPRITE_CONFIG.frameHeight,
									SPRITE_CONFIG.frameWidth,
									SPRITE_CONFIG.frameHeight,
								),
							});
							frames.push(frame);
						}
					}

					// Create sprite to display current frame with proper centering
					const sprite = new Sprite(frames[0]);
					sprite.anchor.set(0.5, 0.5); // Center anchor point
					sprite.scale.set(SPRITE_CONFIG.scale);

					// Position sprite at center of canvas
					sprite.x = app.screen.width / 2;
					sprite.y = app.screen.height / 2;

					app.stage.addChild(sprite);

					// Animation state
					let currentFrame = 0;
					let frameTime = 0;
					const frameDelay = 1000 / SPRITE_CONFIG.fps; // milliseconds per frame

					// Smooth animation loop using PixiJS ticker
					app.ticker.add((ticker) => {
						frameTime += ticker.deltaMS;

						// Update frame when enough time has passed
						if (frameTime >= frameDelay) {
							frameTime -= frameDelay;

							// Move to next frame
							currentFrame = (currentFrame + 1) % frames.length;
							sprite.texture = frames[currentFrame];
						}
					});

					// Cleanup function to destroy PixiJS app when loader is hidden
					window.addEventListener("load", () => {
						setTimeout(() => {
							if (app) {
								app.ticker.stop();
								app.destroy(true, {
									children: true,
									texture: false,
								});
							}
						}, 3000); // Destroy after loader fades out
					});
				} catch (error) {
					console.error("Failed to load sprite animation:", error);
					// Fallback spinner
					const fallbackDiv = document.createElement("div");
					fallbackDiv.style.cssText =
						"width: 40px; height: 40px; border: 3px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%; animation: spin 1s linear infinite;";
					canvasElement.parentElement?.appendChild(fallbackDiv);
				}
			}

			// Initialize when DOM is ready
			if (document.readyState === "loading") {
				document.addEventListener(
					"DOMContentLoaded",
					initSpriteAnimation,
				);
			} else {
				initSpriteAnimation();
			}
		</script>

		<slot />
	</body>
</html>

<style>
	html,
	body {
		margin: 0;
		width: 100%;
		height: 100%;
	}

	.loader-wrapper {
		position: fixed;
		inset: 0;
		background: black;
		display: flex;
		align-items: center;
		justify-content: center;
		z-index: 9999;
		opacity: 1;
		transition: opacity 0.5s ease-out;
	}

	.loader-wrapper.fade-out {
		opacity: 0;
		pointer-events: none;
	}

	.loader-content {
		display: flex;
		flex-direction: column;
		align-items: center;
		gap: 2rem;
	}

	#sprite-canvas {
		image-rendering: pixelated;
		image-rendering: crisp-edges;
	}

	@keyframes spin {
		to {
			transform: rotate(360deg);
		}
	}

	/* Progress Bar Container */
	.progress-bar-container {
		width: 300px;
		height: 8px;
		background: rgba(255, 255, 255, 0.1);
		border-radius: 4px;
		overflow: hidden;
		border: 1px solid rgba(255, 255, 255, 0.2);
	}

	/* Progress Bar Fill */
	.progress-bar-fill {
		height: 100%;
		background: linear-gradient(90deg, #4caf50, #8bc34a);
		transition: width 0.3s ease-out;
		border-radius: 4px;
	}

	/* Progress Text */
	.progress-text {
		color: white;
		font-family: monospace;
		font-size: 14px;
		margin-top: -0.5rem;
	}
</style>
