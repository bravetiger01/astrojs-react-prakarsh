---
import "../styles/index.css";

interface Props {
	title?: string;
}

const { title = "Astro Basics" } = Astro.props;
---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width" />

		<meta name="generator" content={Astro.generator} />
		<title>{title}</title>

		<!-- Preload sprite sheet for immediate display -->
		<link
			rel="preload"
			href="/sprites/sprite_sheet.avif"
			as="image"
			fetchpriority="high"
		/>

		<!-- Inline critical loader CSS for instant visibility -->
		<style>
			.loader-wrapper {
				position: fixed;
				inset: 0;
				background: black;
				display: flex;
				align-items: center;
				justify-content: center;
				z-index: 9999;
				opacity: 1;
				transition: opacity 0.5s ease-out;
			}

			.loader-wrapper.fade-out {
				opacity: 0;
				pointer-events: none;
			}

			.loader-content {
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 2rem;
			}

			#sprite-canvas {
				image-rendering: pixelated;
				image-rendering: crisp-edges;
			}

			@keyframes spin {
				to {
					transform: rotate(360deg);
				}
			}
		</style>
	</head>
	<body>
		<!-- Inline Loader HTML - shows immediately -->
		<div id="loader-wrapper" class="loader-wrapper">
			<div class="loader-content">
				<canvas id="sprite-canvas"></canvas>
			</div>
		</div>

		<!-- Inline script - starts progress animation immediately -->
		<script is:inline>
			// Configuration
			var EXPIRY_TIME = 60 * 60 * 1000; // 1 Hour
			var LOCK_KEY = "loaderLastShown";

			// Logic to determine if loader should show
			function shouldShowLoader() {
				// 1. Only show on root path
				if (
					window.location.pathname !== "/" &&
					window.location.pathname !== ""
				) {
					return false;
				}

				// 2. Check session storage for expiration
				var lastShown = sessionStorage.getItem(LOCK_KEY);
				var now = Date.now();

				if (lastShown && now - parseInt(lastShown) < EXPIRY_TIME) {
					return false; // Still within cooldown
				}

				return true; // Show loader
			}

			var showLoader = shouldShowLoader();

			if (!showLoader) {
				// Hide loader immediately
				var loaderWrapper = document.getElementById("loader-wrapper");
				if (loaderWrapper) {
					loaderWrapper.style.display = "none";
				}
			} else {
				// Show loader and set timestamp
				sessionStorage.setItem(LOCK_KEY, Date.now().toString());

				var isHiding = false;
				var loaderWrapper = document.getElementById("loader-wrapper");

				// Listen for load complete event
				function handleLoadComplete() {
					if (isHiding) return;
					isHiding = true;

					setTimeout(function () {
						if (loaderWrapper) {
							loaderWrapper.classList.add("fade-out");
							setTimeout(function () {
								loaderWrapper.style.display = "none";
							}, 500);
						}
					}, 300);
				}

				// Track when the page started loading
				var pageStartTime = Date.now();
				var minimumLoadTime = 5800; // 5 seconds minimum

				// When page resources finish loading
				window.addEventListener("load", function () {
					var elapsedTime = Date.now() - pageStartTime;
					var remainingTime = Math.max(
						0,
						minimumLoadTime - elapsedTime,
					);

					console.log(
						"Window loaded after " +
							elapsedTime +
							"ms, waiting " +
							remainingTime +
							"ms more...",
					);

					// Wait for remaining time to reach 5 seconds total
					setTimeout(function () {
						console.log(
							"Minimum 5 seconds elapsed, completing loader...",
						);
						handleLoadComplete();
					}, remainingTime);
				});
			}
		</script>

		<!-- PixiJS Sprite Animation -->
		<script>
			import {
				Application,
				Assets,
				Sprite,
				Texture,
				Rectangle,
			} from "pixi.js";
			import { prefetchAllEvents } from "../lib/event-cache";

			// Mirror the inline logic to sync state
			const EXPIRY_TIME = 60 * 60 * 1000; // 1 Hour
			const LOCK_KEY = "loaderLastShown";
			const path = window.location.pathname;

			// We can check sessionStorage here, but since inline script already updated it if it ran,
			// we need to be careful. However, we primarily need to know if we *should have* shown it.
			// The inline script sets the key *immediately* if it shows.
			// So if the key was just set a few ms ago, we show.
			// But simpler: just check if the loader DOM is visible?
			// No, that might be racy. Let's re-evaluate the "should show" condition similarly,
			// but relying on the fact that if it *did* show, the key is now set to NOW.

			// Actually, easiest way: Check if the wrapper is display: none.
			// But inline script might run after this module script? No, inline runs first usually?
			// To be safe, let's just stick to the pure logic.
			// Check if we satisfy the condition "Is Root".
			// And checking storage is tricky because inline script just updated it.
			// Let's rely on a data attribute or class on the body? Or just re-calc.

			// If we just updated session storage, the diff (now - lastShown) will be ~0.
			// If we didn't update it, it will be > EXPIRY or null.

			// Let's refine the logic:
			// If not root -> Skip.
			// If root:
			//    Get timestamp.
			//    If timestamp is very recent ( < 5000ms), it means inline script just set it -> SHOW.
			//    If timestamp is old -> It means inline script decided NOT to show (wait, inline logic updates it ONLY if showing).
			//    So if inline script decided NOT to show, it wouldn't have updated the timestamp.
			//    So the timestamp would be OLD.
			//    Wait, if logic is: "If valid cookie -> Don't Show".
			//    Then inline script sees valid cookie -> Hides -> Does NOT update cookie.
			//    Module script sees valid cookie -> Skips.
			//
			//    If NO valid cookie (or expired) -> Inline script sees expired -> Shows -> Updates Cookie to NOW.
			//    Module script sees Cookie is NOW -> Shows.

			const lastShown = sessionStorage.getItem(LOCK_KEY);
			const now = Date.now();
			const isRoot = path === "/" || path === "";
			const isRecent = lastShown && now - parseInt(lastShown) < 5000; // Updated within last 5 seconds

			// If it's root AND the lock was just updated, it means the loader is active.
			// OR if it's the very first time ever? (Lock updated).

			// What if user refreshes immediately?
			// Inline: Cookie is recent -> Hides.
			// Module: Cookie is recent -> But is it *TOO* recent?
			// If cookie is 2 seconds old, Inline HIDES (because < 1 hour).
			// Module sees 2 seconds old.
			// We need to distinguish "Just set by THIS page load" vs "Set by PREVIOUS page load 2s ago".

			// Better approach: Inline script sets a global flag on `window`.
			const shouldShow =
				(window as any).getComputedStyle(
					document.getElementById("loader-wrapper")!,
				).display !== "none";

			if (shouldShow) {
				// Start prefetching events immediately during loading screen
				console.log(
					"üöÄ Starting event prefetch during loading screen...",
				);
				prefetchAllEvents()
					.then(() => {
						console.log("‚úÖ Events prefetched successfully!");
					})
					.catch((error) => {
						console.error("‚ùå Error prefetching events:", error);
					});

				// Sprite sheet configuration - Production settings
				const SPRITE_CONFIG = {
					path: "/sprites/sprite_sheet.avif",
					width: 7500,
					height: 11000,
					columns: 15,
					rows: 22,
					frameWidth: 7500 / 15, // ~733.33px
					frameHeight: 11000 / 22, // ~340.91px
					fps: 60, // 60 FPS for smooth animation
					scale: 0.6, // Larger scale to show complete frames
				};

				async function initSpriteAnimation() {
					const canvasElement =
						document.getElementById("sprite-canvas");
					if (!canvasElement) return;

					// Create PixiJS application with production-level settings
					const app = new Application();
					await app.init({
						canvas: canvasElement as HTMLCanvasElement,
						width: SPRITE_CONFIG.frameWidth * SPRITE_CONFIG.scale,
						height: SPRITE_CONFIG.frameHeight * SPRITE_CONFIG.scale,
						backgroundColor: 0x000000,
						backgroundAlpha: 0,
						antialias: false, // Crisp pixel art rendering
						resolution: window.devicePixelRatio || 1,
						autoDensity: true,
						autoStart: true, // Start rendering immediately
					});

					// Lock to 60 FPS for production-level smoothness
					app.ticker.maxFPS = 60;

					try {
						// Load sprite sheet with caching
						Assets.add({
							alias: "spritesheet",
							src: SPRITE_CONFIG.path,
						});
						const texture = await Assets.load("spritesheet");

						// Create all frames (row by row)
						const frames: Texture[] = [];
						for (let row = 0; row < SPRITE_CONFIG.rows; row++) {
							for (
								let col = 0;
								col < SPRITE_CONFIG.columns;
								col++
							) {
								const frame = new Texture({
									source: texture.source,
									frame: new Rectangle(
										col * SPRITE_CONFIG.frameWidth,
										row * SPRITE_CONFIG.frameHeight,
										SPRITE_CONFIG.frameWidth,
										SPRITE_CONFIG.frameHeight,
									),
								});
								frames.push(frame);
							}
						}

						// Create sprite to display current frame with proper centering
						const sprite = new Sprite(frames[0]);
						sprite.anchor.set(0.5, 0.5); // Center anchor point
						sprite.scale.set(SPRITE_CONFIG.scale);

						// Position sprite at center of canvas
						sprite.x = app.screen.width / 2;
						sprite.y = app.screen.height / 2;

						app.stage.addChild(sprite);

						// Animation state
						let currentFrame = 0;
						let frameTime = 0;
						const frameDelay = 1000 / SPRITE_CONFIG.fps; // milliseconds per frame

						// Smooth animation loop using PixiJS ticker
						app.ticker.add((ticker) => {
							frameTime += ticker.deltaMS;

							// Update frame when enough time has passed
							if (frameTime >= frameDelay) {
								frameTime -= frameDelay;

								// Move to next frame
								currentFrame =
									(currentFrame + 1) % frames.length;
								sprite.texture = frames[currentFrame];
							}
						});

						// Cleanup function to destroy PixiJS app when loader is hidden
						window.addEventListener("load", () => {
							setTimeout(() => {
								if (app) {
									app.ticker.stop();
									app.destroy(true, {
										children: true,
										texture: false,
									});
								}
							}, 3000); // Destroy after loader fades out
						});
					} catch (error) {
						console.error(
							"Failed to load sprite animation:",
							error,
						);
						// Fallback spinner
						const fallbackDiv = document.createElement("div");
						fallbackDiv.style.cssText =
							"width: 40px; height: 40px; border: 3px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%; animation: spin 1s linear infinite;";
						canvasElement.parentElement?.appendChild(fallbackDiv);
					}
				}

				// Initialize when DOM is ready
				if (document.readyState === "loading") {
					document.addEventListener(
						"DOMContentLoaded",
						initSpriteAnimation,
					);
				} else {
					initSpriteAnimation();
				}
			} else {
				// Loader was skipped (direct visit to non-root page)
				// Prefetch events in background without blocking
				console.log(
					"üîÑ Prefetching events in background (direct visit)...",
				);
				prefetchAllEvents()
					.then(() => {
						console.log("‚úÖ Background prefetch complete!");
					})
					.catch((error) => {
						console.error("‚ùå Background prefetch error:", error);
					});
			}
		</script>

		<slot />
	</body>
</html>

<style>
	html,
	body {
		margin: 0;
		width: 100%;
		height: 100%;
	}

	.loader-wrapper {
		position: fixed;
		inset: 0;
		background: black;
		display: flex;
		align-items: center;
		justify-content: center;
		z-index: 9999;
		opacity: 1;
		transition: opacity 0.5s ease-out;
	}

	.loader-wrapper.fade-out {
		opacity: 0;
		pointer-events: none;
	}

	.loader-content {
		display: flex;
		flex-direction: column;
		align-items: center;
		gap: 2rem;
	}

	#sprite-canvas {
		image-rendering: pixelated;
		image-rendering: crisp-edges;
	}

	@keyframes spin {
		to {
			transform: rotate(360deg);
		}
	}

	/* Progress Bar Container */
	.progress-bar-container {
		width: 300px;
		height: 8px;
		background: rgba(255, 255, 255, 0.1);
		border-radius: 4px;
		overflow: hidden;
		border: 1px solid rgba(255, 255, 255, 0.2);
	}

	/* Progress Bar Fill */
	.progress-bar-fill {
		height: 100%;
		background: linear-gradient(90deg, #4caf50, #8bc34a);
		transition: width 0.3s ease-out;
		border-radius: 4px;
	}

	/* Progress Text */
	.progress-text {
		color: white;
		font-family: monospace;
		font-size: 14px;
		margin-top: -0.5rem;
	}
</style>
